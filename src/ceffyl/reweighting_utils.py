"""
Script with utilities to take CURN sample weights and do useful stuff with it
"""
import numpy as np
from corner import corner
import matplotlib.patches as mpatches
from tqdm import tqdm


def reweight_bayes_factor(wgts):
    """
    function to compute HD vs CURN bayes factor
    this is computed by using posterior weights from reweighting from
    CURN sample posteriors to HD sample posteriors
    it also computes the variance on the bayes factor

    Equations 10 and 13 of PhysRevD.107.084045

    Inputs
    ------
    wgts : array
        an array of computed weights
    
    Returns
    -------
    bf : float
        HD vs CURN Bayes Factor
    
    var_bf : float
        variance on the measurement of bayes factor
    """

    bf = np.mean(wgts)  # mean BF

    # compute efficiency, effective number of samples, variance of weights
    efficient, n_eff, var_w = efficiency(wgts)

    # compute variance of bayes factor
    var_bf = var_w / n_eff

    return bf, var_bf


def efficiency(wgts):
    """
    Compute the efficiency and effective number of samples from weighting

    Equations 11 and 12 of PhysRevD.107.084045

    Inputs
    ------
    wgts : array
        an array of computed weights
    
    Returns
    -------
    efficiency : float
        the ratio between the effective number of independent samples and the
        total number of samples
    
    n_eff : float
        the effective number of indepedent samples
    
    var_w : float
        the variance on the weights
    """
    n_samples = wgts.shape[0]
    
    var_w = np.var(wgts)
    n_eff = n_samples / (1 + var_w / np.mean(wgts)**2)

    efficiency = n_eff / n_samples

    return efficiency, n_eff, var_w


def weighted_corner(curn_samples, wgts):
    """
    an example of a corner plot, using weights
    this lets us create corner plots of the posteriors of a HD model from a
    CURN model

    Inputs
    ------
    curn_samples : array
        an array of your CURN chain samples for the parameters that you want
        to make a posterior plot (n_param x n_samples)
    
    wgts : array
        array of weights (n_samples)

    Returns
    -------
    fig : matplotlib Figure
        a matplotlib figure class
    """
    if curn_samples.shape[0] != wgts.shape[0]:
        raise ValueError('Mismatched array shapes')

    # first, make a regular corner plot
    hist_kwargs = dict(color='C0', density=True)
    fig = corner(curn_samples, bins=50, color='C0', plot_datapoints=False,
                 hist_kwargs=hist_kwargs)

    # now, plot a weighted corner plot
    hist_kwargs = dict(color='C1', density=True)
    fig = corner(curn_samples, bins=50, color='C1', plot_datapoints=False,
                 fig=fig, weights=wgts, hist_kwargs=hist_kwargs)

    # make custom legend
    handle1 = mpatches.Patch(color='C0', label='CURN samples')
    handle2 = mpatches.Patch(color='C1', label='HD from weighted CURN')
    fig.legend(handles=[handle1, handle2])

    return fig

def hd_resample(curn_samples, curn_ln_post, wgts, n_samples=None):
    """
    utility to generate HD samples from weighted CURN using the
    Gumbel Max trick

    Reference: https://timvieira.github.io/blog/post/2014/07/31/gumbel-max-trick/

    Inputs
    ------
    curn_samples : array (n_param x n_samps)
        an array of your CURN chain samples for the parameters that you want
        to make a posterior plot
    
    curn_ln_post : array (n_samples)
        array of log-posterior values from CURN analysis chain
    
    wgts : array
        array of LINEAR weights (n_samples)

    n_samples : int
        number of samples to generate. If None, then the number of samples
        generated is the number of samples in the CURN chain

    Returns
    -------
    new_hd_samples : array (n_param x n_samples)
        an array of HD samples generated by reweighting CURN array
    
    Raises
    ------
    ValueError
        if sizes of curn_samples, curn_ln_post, or wgts don't match
    """
    if curn_samples.shape[1] != curn_ln_post.shape[0]:
        raise ValueError('Mismatched array shapes')
    if curn_samples.shape[1] != wgts.shape[0]:
        raise ValueError('Mismatched array shapes')

    ln_wgts = np.log(wgts)
    hd_ln_post = curn_ln_post + ln_wgts  # log-posterior of hd chain

    if n_samples is None:
        n_samples = curn_samples.shape[1]
    
    # initialise empty array
    new_hd_samples = np.zeros((curn_samples.shape[0], n_samples))

    for ii in tqdm(range(n_samples)):
        # generate samples from a gumbel distribution
        z = np.random.gumbel(loc=0, scale=1, size=curn_samples.shape[1])

        # find argmax and save the sample
        idx = np.argmax(z + hd_ln_post)

        new_hd_samples[:, ii] = curn_samples[:, idx]

    return new_hd_samples